{"version":3,"sources":["../../src/util/mergeData.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @copyright 2017 Alex Regan\n * @license MIT\n * @see https://github.com/alexsasharegan/vue-functional-data-merge\n */\n/* eslint-disable max-statements */\nimport { VNodeData } from 'vue'\nimport { camelize } from './helpers'\n\nconst pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/,\n} as const\n\nfunction parseStyle (style: string) {\n  const styleMap: Dictionary<any> = {}\n\n  for (const s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp)\n    key = key.trim()\n    if (!key) {\n      continue\n    }\n    // May be undefined if the `key: value` pair is incomplete.\n    if (typeof val === 'string') {\n      val = val.trim()\n    }\n    styleMap[camelize(key)] = val\n  }\n\n  return styleMap\n}\n\n/**\n * Intelligently merges data for createElement.\n * Merges arguments left to right, preferring the right argument.\n * Returns new VNodeData object.\n */\nexport default function mergeData (...vNodeData: VNodeData[]): VNodeData\nexport default function mergeData (): VNodeData {\n  const mergeTarget: VNodeData & Dictionary<any> = {}\n  let i: number = arguments.length\n  let prop: string\n  let event: string\n\n  // Allow for variadic argument length.\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'style':\n        case 'directives':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!Array.isArray(mergeTarget[prop])) {\n            mergeTarget[prop] = []\n          }\n\n          if (prop === 'style') {\n            let style: any[]\n            if (Array.isArray(arguments[i].style)) {\n              style = arguments[i].style\n            } else {\n              style = [arguments[i].style]\n            }\n            for (let j = 0; j < style.length; j++) {\n              const s = style[j]\n              if (typeof s === 'string') {\n                style[j] = parseStyle(s)\n              }\n            }\n            arguments[i].style = style\n          }\n\n          // Repackaging in an array allows Vue runtime\n          // to merge class/style bindings regardless of type.\n          mergeTarget[prop] = mergeTarget[prop].concat(arguments[i][prop])\n          break\n        // Space delimited string concatenation strategy\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = ''\n          }\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' '\n          }\n          mergeTarget[prop] += arguments[i][prop].trim()\n          break\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n        case 'on':\n        case 'nativeOn':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          const listeners = mergeTarget[prop]!\n          for (event of Object.keys(arguments[i][prop] || {})) {\n            // Concat function to array of functions if callback present.\n            if (listeners[event]) {\n              // Insert current iteration data in beginning of merged array.\n              listeners[event] = Array<Function>().concat( // eslint-disable-line\n                listeners[event],\n                arguments[i][prop][event]\n              )\n            } else {\n              // Straight assign.\n              listeners[event] = arguments[i][prop][event]\n            }\n          }\n          break\n        // Object merge strategy\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          mergeTarget[prop] = { ...arguments[i][prop], ...mergeTarget[prop] }\n          break\n        // Reassignment strategy (no merge)\n        case 'slot':\n        case 'key':\n        case 'ref':\n        case 'tag':\n        case 'show':\n        case 'keepAlive':\n        default:\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop]\n          }\n      }\n    }\n  }\n\n  return mergeTarget\n}\n"],"sourceRoot":"","file":"mergeData.js"}